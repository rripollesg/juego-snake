<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Snake ‚Äì Mini juego</title>
<style>
    body{
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:flex-start;
        height:100vh;
        margin:0;
        background:#111;
        color:#eee;
        font-family:Arial,Helvetica,sans-serif;
    }
    h1{margin-top:20px;}
    #gameCanvas{
        background:#222;
        border:4px solid #555;
        margin-top:10px;
        image-rendering:pixelated;
    }
    #info{
        margin-top:10px;
        font-size:1.2rem;
    }
    #startBtn{
        margin-top:15px;
        padding:8px 16px;
        font-size:1rem;
        background:#27ae60;
        color:#fff;
        border:none;
        border-radius:4px;
        cursor:pointer;
    }
    #startBtn:hover{background:#2ecc71;}
</style>
</head>
<body>

<h1>üêç Snake</h1>

<canvas id="gameCanvas" width="400" height="400" tabindex="0"></canvas>

<div id="info">
    Puntuaci√≥n: <span id="score">0</span> |
    Velocidad: <span id="speed">5</span> FPS
</div>

<button id="startBtn">Iniciar juego</button>

<script>
/* -------------------------------------------------
 *  1Ô∏è‚É£  CONFIGURACI√ìN B√ÅSICA
 * ------------------------------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const CELL_SIZE = 20;                     // p√≠xeles por celda
const COLS = canvas.width / CELL_SIZE;    // 20 columnas
const ROWS = canvas.height / CELL_SIZE;   // 20 filas

// Direcciones (flechas + WASD)
const DIRECTIONS = {
    ArrowUp:    {x:0, y:-1},
    ArrowDown:  {x:0, y:1},
    ArrowLeft:  {x:-1, y:0},
    ArrowRight: {x:1, y:0},
    w: {x:0, y:-1},
    s: {x:0, y:1},
    a: {x:-1, y:0},
    d: {x:1, y:0}
};

/* -------------------------------------------------
 *  2Ô∏è‚É£  ESTADO DEL JUEGO
 * ------------------------------------------------- */
let snake = [];          // array de segmentos {x,y}
let direction = {x:0, y:0};
let food = null;
let score = 0;
let fps = 5;             // velocidad inicial (frames por segundo)
let animationId = null;  // id de requestAnimationFrame

const scoreEl   = document.getElementById('score');
const speedEl   = document.getElementById('speed');
const startBtn  = document.getElementById('startBtn');

/* -------------------------------------------------
 *  3Ô∏è‚É£  INICIALIZAR / REINICIAR
 * ------------------------------------------------- */
function resetGame() {
    // Posici√≥n inicial centrada
    snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
    // Direcci√≥n por defecto: a la derecha (puedes cambiar a {0,0} si prefieres esperar a que el jugador pulse una tecla)
    direction = {x:1, y:0};
    score = 0;
    fps = 5;
    scoreEl.textContent = score;
    speedEl.textContent = fps;
    placeFood();
    draw();                 // dibuja el estado inicial
}

/* -------------------------------------------------
 *  4Ô∏è‚É£  CONTROL DE TECLADO
 * ------------------------------------------------- */
function handleKey(e){
    const dir = DIRECTIONS[e.key];
    if (!dir) return;               // tecla no v√°lida

    // Evitar invertir la direcci√≥n cuando la serpiente tiene m√°s de 1 segmento
    if (snake.length > 1) {
        const nextX = snake[0].x + dir.x;
        const nextY = snake[0].y + dir.y;
        if (nextX === snake[1].x && nextY === snake[1].y) return;
    }
    direction = dir;
}

/* -------------------------------------------------
 *  5Ô∏è‚É£  BUCLE DE JUEGO (requestAnimationFrame)
 * ------------------------------------------------- */
let lastTick = 0;   // marca de tiempo del √∫ltimo frame

function gameLoop(timestamp){
    // Controlamos la velocidad mediante fps
    if (timestamp - lastTick >= 1000 / fps){
        update();          // l√≥gica del juego
        lastTick = timestamp;
    }
    animationId = requestAnimationFrame(gameLoop);
}

/* -------------------------------------------------
 *  6Ô∏è‚É£  L√ìGICA DEL JUEGO
 * ------------------------------------------------- */
function update(){
    // 1Ô∏è‚É£ Calcular nueva cabeza
    const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
    };

    // 2Ô∏è‚É£ Colisi√≥n con paredes
    if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS){
        gameOver();
        return;
    }

    // 3Ô∏è‚É£ Colisi√≥n consigo misma (ignorar la cabeza actual)
    if (snake.slice(1).some(seg => seg.x === head.x && seg.y === head.y)){
        gameOver();
        return;
    }

    // 4Ô∏è‚É£ Insertar nueva cabeza
    snake.unshift(head);

    // 5Ô∏è‚É£ ¬øComi√≥ la fruta?
    if (head.x === food.x && head.y === food.y){
        ++score;
        fps = Math.min(15, fps + 0.5);   // l√≠mite de velocidad
        scoreEl.textContent = score;
        speedEl.textContent = fps.toFixed(1);
        placeFood();                     // generar nueva fruta
    }else{
        // 6Ô∏è‚É£ No comi√≥ ‚Üí eliminar la cola
        snake.pop();
    }

    draw(); // volver a pintar
}

/* -------------------------------------------------
 *  7Ô∏è‚É£  DIBUJAR EN EL CANVAS
 * ------------------------------------------------- */
function draw(){
    // Fondo
    ctx.fillStyle = '#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Fruta
    ctx.fillStyle = '#e74c3c';
    ctx.fillRect(food.x*CELL_SIZE, food.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);

    // Serpiente
    snake.forEach((seg, idx) => {
        ctx.fillStyle = idx===0 ? '#27ae60' : '#2ecc71'; // cabeza distinta
        ctx.fillRect(seg.x*CELL_SIZE, seg.y*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    });
}

/* -------------------------------------------------
 *  8Ô∏è‚É£  POSICIONAR FRUTA ALEATORIAMENTE
 * ------------------------------------------------- */
function placeFood(){
    let pos;
    do{
        pos = {
            x: Math.floor(Math.random()*COLS),
            y: Math.floor(Math.random()*ROWS)
        };
    }while (snake.some(s => s.x===pos.x && s.y===pos.y));
    food = pos;
}

/* -------------------------------------------------
 *  9Ô∏è‚É£  GAME OVER
 * ------------------------------------------------- */
function gameOver(){
    cancelAnimationFrame(animationId);
    alert(`¬°Game Over!\nPuntuaci√≥n: ${score}`);
    resetGame();               // vuelve al estado inicial
    startBtn.disabled = false; // permite volver a iniciar
}

/* -------------------------------------------------
 *  üîü  INICIAR JUEGO (bot√≥n)
 * ------------------------------------------------- */
startBtn.addEventListener('click', () => {
    resetGame();               // asegura estado limpio
    canvas.focus();            // para que el teclado funcione
    startBtn.disabled = true;  // mientras se juega
    lastTick = 0;
    animationId = requestAnimationFrame(gameLoop);
});

/* -------------------------------------------------
 *  11Ô∏è‚É£  EVENTOS DE TECLADO
 * ------------------------------------------------- */
document.addEventListener('keydown', handleKey);

/* -------------------------------------------------
 *  12Ô∏è‚É£  CARGA INICIAL (esperamos DOM listo)
 * ------------------------------------------------- */
window.addEventListener('DOMContentLoaded', () => {
    resetGame();   // dibuja serpiente y fruta aunque el juego a√∫n no haya comenzado
});
</script>

</body>
</html>